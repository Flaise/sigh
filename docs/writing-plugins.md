# Writing sigh plugins

First make a node module for your plugin and in the main library file as indicated by package.json (which defaults to index.js) put something like this:

```javascript
// this plugin adds a redundant variable statement at the end of each javascript file
module.exports = function(operation, text) {
  // do whatever you want with the stream here, see https://baconjs.github.io/
  return operation.stream.map(function(events) {
    return events.map(function(event) {
      if (event.type !== 'remove' && event.fileType === 'js')
        event.data += '\nvar variable = "' + (text || "stuff") + '"'
      // you should make sure to call "event.applySourceMap" usually with
      // source maps generated by the current operation.
      return event
    })
  })
}
```
The first argument is used to pass information to the plugin, the subsequent arguments are passed from the arguments used within the `Sigh.js` file. The `operation` argument has the following fields:

 * `stream`: Bacon.js stream to adapt.
 * `treeIndex`: depth-first index of operator within pipeline tree. This can be written to in order to this to set the treeIndex for the next pipeline operation otherwise it is incremented by one.
 * `watch`: true if and only if the `-w` flag was used.
 * `environment`: environment being built (change with the `-e` or `--environment` flag).
 * `procPool`: A [ProcessPool](https://github.com/ohjames/process-pool) instance configured to limit the number of active processes accoring to the `-j` argument passed to sigh. This can be used to schedule work over multiple CPUs, see the [sigh-babel plugin](https://github.com/sighjs/sigh-babel/blob/master/src/index.js) for an example.
 * `compiler`: a pipeline compiler that can be used to compile any sub-trees, this is used in advanced plugins that take other pipelines as arguments.

The [sigh-core](https://github.com/sighjs/sigh-core) library also provides some functionality useful for writing plugins including access to the `Bacon` instance sigh uses.

Assuming the plugin above is called `suffixer` it could be used in a Sighfile like:
```javascript
module.exports = function(pipelines) {
  pipelines['js'] = [ glob('*.js'), suffixer('kittens'), write('build') ]
}
```

The stream payload is an array of event objects, each event object contains the following fields:
  * `type`: `add`, `change`, or `remove`
  * `path`: path to source file.
  * `sourceMap`: source map as javascript object, this is read-write but in most cases `applySourceMap` should be used instead of writing to this variable.
  * `data`: file content as string (plugins can modify this, if modified then applySourceMap should be called with a source map describing the modifications).
  * `sourceData`: original content before any transforms (read-only).
  * `fileType`: filename extension (read-only).
  * `basePath`: optional base directory containing resource.
  * `projectPath`: path with basePath stripped off.
  * `opTreeIndex`: depth-first index (within asset pipeline tree) of the source operator for this event.

The first array in the stream always contains an event of type `add` for every source file.

The following methods are available:
  * `applySourceMap(nextSourceMap)`: apply a new source map on top of the resource's existing source map.

Plugins can also return a `Promise` to delay construction of the pipeline.

## Incremental rebuilds and plugins

Due to the way Sigh's event stream works processing never needs to be repeated, only work relating to the actual files changed is performed. In most cases caching isn't necessary, in the few cases where it is Sigh handles it transparently. Library code available to plugin writers makes it simple to handle caching in cases where it is necessary.

# Future updates to this document
* Document file coalescing, for now see the [concat plugin](https://github.com/sighjs/sigh/blob/master/src/plugin/concat.js) and [toFileSystemState](https://github.com/sighjs/sigh-core/blob/master/src/stream.js).
